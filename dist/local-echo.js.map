{"version":3,"sources":["webpack://LocalEchoController/webpack/bootstrap","webpack://LocalEchoController/./node_modules/shell-quote/index.js","webpack://LocalEchoController/./node_modules/jsonify/index.js","webpack://LocalEchoController/./node_modules/jsonify/lib/parse.js","webpack://LocalEchoController/./node_modules/jsonify/lib/stringify.js","webpack://LocalEchoController/./node_modules/array-map/index.js","webpack://LocalEchoController/./node_modules/array-filter/index.js","webpack://LocalEchoController/./node_modules/array-reduce/index.js","webpack://LocalEchoController/./node_modules/ansi-regex/index.js","webpack://LocalEchoController/./lib/HistoryController.js","webpack://LocalEchoController/./lib/Utils.js","webpack://LocalEchoController/./lib/LocalEchoController.js","webpack://LocalEchoController/./index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","json","undefined","JSON","map","filter","reduce","quote","xs","op","replace","test","String","join","CONTROL","BAREWORD","SINGLE_QUOTE","DOUBLE_QUOTE","TOKEN","Math","pow","random","toString","parse","env","opts","mapped","chunker","RegExp","match","Boolean","commented","j","BS","escape","esc","out","isGlob","len","length","charAt","parseEnvVar","comment","slice","pattern","varend","varname","Error","substr","indexOf","index","_","pre","stringify","getVar","prev","arg","concat","acc","split","x","at","ch","text","escapee","\"","\\","/","b","f","error","message","next","number","string","isFinite","hex","uffff","parseInt","fromCharCode","white","array","push","word","source","reviver","result","walk","holder","k","v","","gap","indent","rep","escapable","meta","\b","\t","\n","\f","\r","lastIndex","a","charCodeAt","replacer","space","str","partial","mind","toJSON","apply","res","hasOwn","arr","fn","ret","hasAcc","arguments","ansiRegex","onlyFirst","HistoryController","size","_classCallCheck","this","entries","cursor","_createClass","entry","trim","shift","idx","max","min","wordBoundaries","input","leftSide","words","rx","exec","closestLeftBoundary","offset","found","reverse","find","offsetToColRow","maxCols","row","col","countLines","hasTailingWhitespace","getLastToken","shell_quote","pop","LocalEchoController_LocalEchoController","LocalEchoController","term","options","LocalEchoController_classCallCheck","_handleTermData","handleTermData","_handleTermResize","handleTermResize","history","historySize","maxAutocompleteEntries","_autocompleteHandlers","_active","_input","_cursor","_activePrompt","_activeCharPrompt","_termSize","cols","rows","_disposables","loadAddon","attach","detach","off","forEach","dispose","on","onData","onResize","_len","args","Array","_key","findIndex","e","splice","prompt","_this","continuationPrompt","Promise","resolve","reject","write","_this2","reason","print","normInput","items","padding","println","itemWidth","width","item","wideCols","floor","wideRows","ceil","rowStr","repeat","applyPrompts","currentPrompt","allRows","_offsetToColRow","applyPromptOffset","moveRows","newInput","clearInput","newPrompt","newCursor","newLines","_offsetToColRow2","moveUpRows","callback","_this3","setCursor","resume","setInput","then","inputWithPrompt","_offsetToColRow3","prevCol","prevRow","_offsetToColRow4","newCol","newRow","dir","num","backspace","data","_this4","normData","from","handleData","_this5","ofs","ord","getPrevious","getNext","handleCursorMove","handleCursorErase","closestRightBoundary","endsWith","isIncompleteInput","handleReadComplete","handleCursorInsert","inputFragment","hasTailingSpace","candidates","callbacks","tokens","expr","_ref","_toConsumableArray","console","txt","startsWith","collectAutocompleteCandidates","sort","lastToken","sameFragment","getSharedFragment","fragment","oldFragment","printAndRestartPrompt","printWide","readChar","yn","rewind","__webpack_exports__"],"mappings":"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","file":"local-echo.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","var json = typeof JSON !== undefined ? JSON : require('jsonify');\nvar map = require('array-map');\nvar filter = require('array-filter');\nvar reduce = require('array-reduce');\n\nexports.quote = function (xs) {\n    return map(xs, function (s) {\n        if (s && typeof s === 'object') {\n            return s.op.replace(/(.)/g, '\\\\$1');\n        }\n        else if (/[\"\\s]/.test(s) && !/'/.test(s)) {\n            return \"'\" + s.replace(/(['\\\\])/g, '\\\\$1') + \"'\";\n        }\n        else if (/[\"'\\s]/.test(s)) {\n            return '\"' + s.replace(/([\"\\\\$`!])/g, '\\\\$1') + '\"';\n        }\n        else {\n            return String(s).replace(/([#!\"$&'()*,:;<=>?@\\[\\\\\\]^`{|}])/g, '\\\\$1'); \n        }\n    }).join(' ');\n};\n\nvar CONTROL = '(?:' + [\n    '\\\\|\\\\|', '\\\\&\\\\&', ';;', '\\\\|\\\\&', '[&;()|<>]'\n].join('|') + ')';\nvar META = '|&;()<> \\\\t';\nvar BAREWORD = '(\\\\\\\\[\\'\"' + META + ']|[^\\\\s\\'\"' + META + '])+';\nvar SINGLE_QUOTE = '\"((\\\\\\\\\"|[^\"])*?)\"';\nvar DOUBLE_QUOTE = '\\'((\\\\\\\\\\'|[^\\'])*?)\\'';\n\nvar TOKEN = '';\nfor (var i = 0; i < 4; i++) {\n    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);\n}\n\nexports.parse = function (s, env, opts) {\n    var mapped = parse(s, env, opts);\n    if (typeof env !== 'function') return mapped;\n    return reduce(mapped, function (acc, s) {\n        if (typeof s === 'object') return acc.concat(s);\n        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));\n        if (xs.length === 1) return acc.concat(xs[0]);\n        return acc.concat(map(filter(xs, Boolean), function (x) {\n            if (RegExp('^' + TOKEN).test(x)) {\n                return json.parse(x.split(TOKEN)[1]);\n            }\n            else return x;\n        }));\n    }, []);\n};\n\nfunction parse (s, env, opts) {\n    var chunker = new RegExp([\n        '(' + CONTROL + ')', // control chars\n        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'\n    ].join('|'), 'g');\n    var match = filter(s.match(chunker), Boolean);\n    var commented = false;\n\n    if (!match) return [];\n    if (!env) env = {};\n    if (!opts) opts = {};\n    return map(match, function (s, j) {\n        if (commented) {\n            return;\n        }\n        if (RegExp('^' + CONTROL + '$').test(s)) {\n            return { op: s };\n        }\n\n        // Hand-written scanner/parser for Bash quoting rules:\n        //\n        //  1. inside single quotes, all characters are printed literally.\n        //  2. inside double quotes, all characters are printed literally\n        //     except variables prefixed by '$' and backslashes followed by\n        //     either a double quote or another backslash.\n        //  3. outside of any quotes, backslashes are treated as escape\n        //     characters and not printed (unless they are themselves escaped)\n        //  4. quote context can switch mid-token if there is no whitespace\n        //     between the two quote contexts (e.g. all'one'\"token\" parses as\n        //     \"allonetoken\")\n        var SQ = \"'\";\n        var DQ = '\"';\n        var DS = '$';\n        var BS = opts.escape || '\\\\';\n        var quote = false;\n        var esc = false;\n        var out = '';\n        var isGlob = false;\n\n        for (var i = 0, len = s.length; i < len; i++) {\n            var c = s.charAt(i);\n            isGlob = isGlob || (!quote && (c === '*' || c === '?'));\n            if (esc) {\n                out += c;\n                esc = false;\n            }\n            else if (quote) {\n                if (c === quote) {\n                    quote = false;\n                }\n                else if (quote == SQ) {\n                    out += c;\n                }\n                else { // Double quote\n                    if (c === BS) {\n                        i += 1;\n                        c = s.charAt(i);\n                        if (c === DQ || c === BS || c === DS) {\n                            out += c;\n                        } else {\n                            out += BS + c;\n                        }\n                    }\n                    else if (c === DS) {\n                        out += parseEnvVar();\n                    }\n                    else {\n                        out += c;\n                    }\n                }\n            }\n            else if (c === DQ || c === SQ) {\n                quote = c;\n            }\n            else if (RegExp('^' + CONTROL + '$').test(c)) {\n                return { op: s };\n            }\n            else if (RegExp('^#$').test(c)) {\n                commented = true;\n                if (out.length){\n                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n                }\n                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];\n            }\n            else if (c === BS) {\n                esc = true;\n            }\n            else if (c === DS) {\n                out += parseEnvVar();\n            }\n            else out += c;\n        }\n\n        if (isGlob) return {op: 'glob', pattern: out};\n\n        return out;\n\n        function parseEnvVar() {\n            i += 1;\n            var varend, varname;\n            //debugger\n            if (s.charAt(i) === '{') {\n                i += 1;\n                if (s.charAt(i) === '}') {\n                    throw new Error(\"Bad substitution: \" + s.substr(i - 2, 3));\n                }\n                varend = s.indexOf('}', i);\n                if (varend < 0) {\n                    throw new Error(\"Bad substitution: \" + s.substr(i));\n                }\n                varname = s.substr(i, varend - i);\n                i = varend;\n            }\n            else if (/[*@#?$!_\\-]/.test(s.charAt(i))) {\n                varname = s.charAt(i);\n                i += 1;\n            }\n            else {\n                varend = s.substr(i).match(/[^\\w\\d_]/);\n                if (!varend) {\n                    varname = s.substr(i);\n                    i = s.length;\n                } else {\n                    varname = s.substr(i, varend.index);\n                    i += varend.index - 1;\n                }\n            }\n            return getVar(null, '', varname);\n        }\n    })\n    // finalize parsed aruments\n    .reduce(function(prev, arg){\n        if (arg === undefined){\n            return prev;\n        }\n        return prev.concat(arg);\n    },[]);\n\n    function getVar (_, pre, key) {\n        var r = typeof env === 'function' ? env(key) : env[key];\n        if (r === undefined) r = '';\n\n        if (typeof r === 'object') {\n            return pre + TOKEN + json.stringify(r) + TOKEN;\n        }\n        else return pre + r;\n    }\n}\n","exports.parse = require('./lib/parse');\nexports.stringify = require('./lib/stringify');\n","var at, // The index of the current character\n    ch, // The current character\n    escapee = {\n        '\"':  '\"',\n        '\\\\': '\\\\',\n        '/':  '/',\n        b:    '\\b',\n        f:    '\\f',\n        n:    '\\n',\n        r:    '\\r',\n        t:    '\\t'\n    },\n    text,\n\n    error = function (m) {\n        // Call error when something is wrong.\n        throw {\n            name:    'SyntaxError',\n            message: m,\n            at:      at,\n            text:    text\n        };\n    },\n    \n    next = function (c) {\n        // If a c parameter is provided, verify that it matches the current character.\n        if (c && c !== ch) {\n            error(\"Expected '\" + c + \"' instead of '\" + ch + \"'\");\n        }\n        \n        // Get the next character. When there are no more characters,\n        // return the empty string.\n        \n        ch = text.charAt(at);\n        at += 1;\n        return ch;\n    },\n    \n    number = function () {\n        // Parse a number value.\n        var number,\n            string = '';\n        \n        if (ch === '-') {\n            string = '-';\n            next('-');\n        }\n        while (ch >= '0' && ch <= '9') {\n            string += ch;\n            next();\n        }\n        if (ch === '.') {\n            string += '.';\n            while (next() && ch >= '0' && ch <= '9') {\n                string += ch;\n            }\n        }\n        if (ch === 'e' || ch === 'E') {\n            string += ch;\n            next();\n            if (ch === '-' || ch === '+') {\n                string += ch;\n                next();\n            }\n            while (ch >= '0' && ch <= '9') {\n                string += ch;\n                next();\n            }\n        }\n        number = +string;\n        if (!isFinite(number)) {\n            error(\"Bad number\");\n        } else {\n            return number;\n        }\n    },\n    \n    string = function () {\n        // Parse a string value.\n        var hex,\n            i,\n            string = '',\n            uffff;\n        \n        // When parsing for string values, we must look for \" and \\ characters.\n        if (ch === '\"') {\n            while (next()) {\n                if (ch === '\"') {\n                    next();\n                    return string;\n                } else if (ch === '\\\\') {\n                    next();\n                    if (ch === 'u') {\n                        uffff = 0;\n                        for (i = 0; i < 4; i += 1) {\n                            hex = parseInt(next(), 16);\n                            if (!isFinite(hex)) {\n                                break;\n                            }\n                            uffff = uffff * 16 + hex;\n                        }\n                        string += String.fromCharCode(uffff);\n                    } else if (typeof escapee[ch] === 'string') {\n                        string += escapee[ch];\n                    } else {\n                        break;\n                    }\n                } else {\n                    string += ch;\n                }\n            }\n        }\n        error(\"Bad string\");\n    },\n\n    white = function () {\n\n// Skip whitespace.\n\n        while (ch && ch <= ' ') {\n            next();\n        }\n    },\n\n    word = function () {\n\n// true, false, or null.\n\n        switch (ch) {\n        case 't':\n            next('t');\n            next('r');\n            next('u');\n            next('e');\n            return true;\n        case 'f':\n            next('f');\n            next('a');\n            next('l');\n            next('s');\n            next('e');\n            return false;\n        case 'n':\n            next('n');\n            next('u');\n            next('l');\n            next('l');\n            return null;\n        }\n        error(\"Unexpected '\" + ch + \"'\");\n    },\n\n    value,  // Place holder for the value function.\n\n    array = function () {\n\n// Parse an array value.\n\n        var array = [];\n\n        if (ch === '[') {\n            next('[');\n            white();\n            if (ch === ']') {\n                next(']');\n                return array;   // empty array\n            }\n            while (ch) {\n                array.push(value());\n                white();\n                if (ch === ']') {\n                    next(']');\n                    return array;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad array\");\n    },\n\n    object = function () {\n\n// Parse an object value.\n\n        var key,\n            object = {};\n\n        if (ch === '{') {\n            next('{');\n            white();\n            if (ch === '}') {\n                next('}');\n                return object;   // empty object\n            }\n            while (ch) {\n                key = string();\n                white();\n                next(':');\n                if (Object.hasOwnProperty.call(object, key)) {\n                    error('Duplicate key \"' + key + '\"');\n                }\n                object[key] = value();\n                white();\n                if (ch === '}') {\n                    next('}');\n                    return object;\n                }\n                next(',');\n                white();\n            }\n        }\n        error(\"Bad object\");\n    };\n\nvalue = function () {\n\n// Parse a JSON value. It could be an object, an array, a string, a number,\n// or a word.\n\n    white();\n    switch (ch) {\n    case '{':\n        return object();\n    case '[':\n        return array();\n    case '\"':\n        return string();\n    case '-':\n        return number();\n    default:\n        return ch >= '0' && ch <= '9' ? number() : word();\n    }\n};\n\n// Return the json_parse function. It will have access to all of the above\n// functions and variables.\n\nmodule.exports = function (source, reviver) {\n    var result;\n    \n    text = source;\n    at = 0;\n    ch = ' ';\n    result = value();\n    white();\n    if (ch) {\n        error(\"Syntax error\");\n    }\n\n    // If there is a reviver function, we recursively walk the new structure,\n    // passing each name/value pair to the reviver function for possible\n    // transformation, starting with a temporary root object that holds the result\n    // in an empty key. If there is not a reviver function, we simply return the\n    // result.\n\n    return typeof reviver === 'function' ? (function walk(holder, key) {\n        var k, v, value = holder[key];\n        if (value && typeof value === 'object') {\n            for (k in value) {\n                if (Object.prototype.hasOwnProperty.call(value, k)) {\n                    v = walk(value, k);\n                    if (v !== undefined) {\n                        value[k] = v;\n                    } else {\n                        delete value[k];\n                    }\n                }\n            }\n        }\n        return reviver.call(holder, key, value);\n    }({'': result}, '')) : result;\n};\n","var cx = /[\\u0000\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    escapable = /[\\\\\\\"\\x00-\\x1f\\x7f-\\x9f\\u00ad\\u0600-\\u0604\\u070f\\u17b4\\u17b5\\u200c-\\u200f\\u2028-\\u202f\\u2060-\\u206f\\ufeff\\ufff0-\\uffff]/g,\n    gap,\n    indent,\n    meta = {    // table of character substitutions\n        '\\b': '\\\\b',\n        '\\t': '\\\\t',\n        '\\n': '\\\\n',\n        '\\f': '\\\\f',\n        '\\r': '\\\\r',\n        '\"' : '\\\\\"',\n        '\\\\': '\\\\\\\\'\n    },\n    rep;\n\nfunction quote(string) {\n    // If the string contains no control characters, no quote characters, and no\n    // backslash characters, then we can safely slap some quotes around it.\n    // Otherwise we must also replace the offending characters with safe escape\n    // sequences.\n    \n    escapable.lastIndex = 0;\n    return escapable.test(string) ? '\"' + string.replace(escapable, function (a) {\n        var c = meta[a];\n        return typeof c === 'string' ? c :\n            '\\\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);\n    }) + '\"' : '\"' + string + '\"';\n}\n\nfunction str(key, holder) {\n    // Produce a string from holder[key].\n    var i,          // The loop counter.\n        k,          // The member key.\n        v,          // The member value.\n        length,\n        mind = gap,\n        partial,\n        value = holder[key];\n    \n    // If the value has a toJSON method, call it to obtain a replacement value.\n    if (value && typeof value === 'object' &&\n            typeof value.toJSON === 'function') {\n        value = value.toJSON(key);\n    }\n    \n    // If we were called with a replacer function, then call the replacer to\n    // obtain a replacement value.\n    if (typeof rep === 'function') {\n        value = rep.call(holder, key, value);\n    }\n    \n    // What happens next depends on the value's type.\n    switch (typeof value) {\n        case 'string':\n            return quote(value);\n        \n        case 'number':\n            // JSON numbers must be finite. Encode non-finite numbers as null.\n            return isFinite(value) ? String(value) : 'null';\n        \n        case 'boolean':\n        case 'null':\n            // If the value is a boolean or null, convert it to a string. Note:\n            // typeof null does not produce 'null'. The case is included here in\n            // the remote chance that this gets fixed someday.\n            return String(value);\n            \n        case 'object':\n            if (!value) return 'null';\n            gap += indent;\n            partial = [];\n            \n            // Array.isArray\n            if (Object.prototype.toString.apply(value) === '[object Array]') {\n                length = value.length;\n                for (i = 0; i < length; i += 1) {\n                    partial[i] = str(i, value) || 'null';\n                }\n                \n                // Join all of the elements together, separated with commas, and\n                // wrap them in brackets.\n                v = partial.length === 0 ? '[]' : gap ?\n                    '[\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + ']' :\n                    '[' + partial.join(',') + ']';\n                gap = mind;\n                return v;\n            }\n            \n            // If the replacer is an array, use it to select the members to be\n            // stringified.\n            if (rep && typeof rep === 'object') {\n                length = rep.length;\n                for (i = 0; i < length; i += 1) {\n                    k = rep[i];\n                    if (typeof k === 'string') {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            else {\n                // Otherwise, iterate through all of the keys in the object.\n                for (k in value) {\n                    if (Object.prototype.hasOwnProperty.call(value, k)) {\n                        v = str(k, value);\n                        if (v) {\n                            partial.push(quote(k) + (gap ? ': ' : ':') + v);\n                        }\n                    }\n                }\n            }\n            \n        // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        v = partial.length === 0 ? '{}' : gap ?\n            '{\\n' + gap + partial.join(',\\n' + gap) + '\\n' + mind + '}' :\n            '{' + partial.join(',') + '}';\n        gap = mind;\n        return v;\n    }\n}\n\nmodule.exports = function (value, replacer, space) {\n    var i;\n    gap = '';\n    indent = '';\n    \n    // If the space parameter is a number, make an indent string containing that\n    // many spaces.\n    if (typeof space === 'number') {\n        for (i = 0; i < space; i += 1) {\n            indent += ' ';\n        }\n    }\n    // If the space parameter is a string, it will be used as the indent string.\n    else if (typeof space === 'string') {\n        indent = space;\n    }\n\n    // If there is a replacer, it must be a function or an array.\n    // Otherwise, throw an error.\n    rep = replacer;\n    if (replacer && typeof replacer !== 'function'\n    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {\n        throw new Error('JSON.stringify');\n    }\n    \n    // Make a fake root object containing our value under the key of ''.\n    // Return the result of stringifying the value.\n    return str('', {'': value});\n};\n","module.exports = function (xs, f) {\n    if (xs.map) return xs.map(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        var x = xs[i];\n        if (hasOwn.call(xs, i)) res.push(f(x, i, xs));\n    }\n    return res;\n};\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n","/**\n * Array#filter.\n *\n * @param {Array} arr\n * @param {Function} fn\n * @return {Array}\n */\n\nmodule.exports = function (arr, fn) {\n  if (arr.filter) return arr.filter(fn);\n  var ret = [];\n  for (var i = 0; i < arr.length; i++) {\n    if (!hasOwn.call(arr, i)) continue;\n    if (fn(arr[i], i, arr)) ret.push(arr[i]);\n  }\n  return ret;\n};\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n","var hasOwn = Object.prototype.hasOwnProperty;\n\nmodule.exports = function (xs, f, acc) {\n    var hasAcc = arguments.length >= 3;\n    if (hasAcc && xs.reduce) return xs.reduce(f, acc);\n    if (xs.reduce) return xs.reduce(f);\n    \n    for (var i = 0; i < xs.length; i++) {\n        if (!hasOwn.call(xs, i)) continue;\n        if (!hasAcc) {\n            acc = xs[i];\n            hasAcc = true;\n            continue;\n        }\n        acc = f(acc, xs[i], i);\n    }\n    return acc;\n};\n","export default function ansiRegex({onlyFirst = false} = {}) {\n\tconst pattern = [\n\t    '[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]+)*|[a-zA-Z\\\\d]+(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)',\n\t\t'(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))'\n\t].join('|');\n\n\treturn new RegExp(pattern, onlyFirst ? undefined : 'g');\n}\n","/**\r\n * The history controller provides an ring-buffer\r\n */\r\nexport class HistoryController {\r\n  constructor(size) {\r\n    this.size = size;\r\n    this.entries = [];\r\n    this.cursor = 0;\r\n  }\r\n\r\n  /**\r\n   * Push an entry and maintain ring buffer size\r\n   */\r\n  push(entry) {\r\n    // Skip empty entries\r\n    if (entry.trim() === \"\") return;\r\n    // Skip duplicate entries\r\n    const lastEntry = this.entries[this.entries.length - 1];\r\n    if (entry == lastEntry) return;\r\n    // Keep track of entries\r\n    this.entries.push(entry);\r\n    if (this.entries.length > this.size) {\r\n      this.entries.shift();\r\n    }\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Rewind history cursor on the last entry\r\n   */\r\n  rewind() {\r\n    this.cursor = this.entries.length;\r\n  }\r\n\r\n  /**\r\n   * Returns the previous entry\r\n   */\r\n  getPrevious() {\r\n    const idx = Math.max(0, this.cursor - 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n\r\n  /**\r\n   * Returns the next entry\r\n   */\r\n  getNext() {\r\n    const idx = Math.min(this.entries.length, this.cursor + 1);\r\n    this.cursor = idx;\r\n    return this.entries[idx];\r\n  }\r\n}\r\n","import ansiRegex from \"ansi-regex\";\r\nimport { parse } from \"shell-quote\";\r\n\r\n/**\r\n * Detects all the word boundaries on the given input\r\n */\r\nexport function wordBoundaries(input, leftSide = true) {\r\n  let match;\r\n  const words = [];\r\n  const rx = /\\w+/g;\r\n\r\n  while ((match = rx.exec(input))) {\r\n    if (leftSide) {\r\n      words.push(match.index);\r\n    } else {\r\n      words.push(match.index + match[0].length);\r\n    }\r\n  }\r\n\r\n  return words;\r\n}\r\n\r\n/**\r\n * The closest left (or right) word boundary of the given input at the\r\n * given offset.\r\n */\r\nexport function closestLeftBoundary(input, offset) {\r\n  const found = wordBoundaries(input, true)\r\n    .reverse()\r\n    .find(x => x < offset);\r\n  return found == null ? 0 : found;\r\n}\r\nexport function closestRightBoundary(input, offset) {\r\n  const found = wordBoundaries(input, false).find(x => x > offset);\r\n  return found == null ? input.length : found;\r\n}\r\n\r\n/**\r\n * Convert offset at the given input to col/row location\r\n *\r\n * This function is not optimized and practically emulates via brute-force\r\n * the navigation on the terminal, wrapping when they reach the column width.\r\n */\r\nexport function offsetToColRow(input, offset, maxCols) {\r\n  let row = 0,\r\n    col = 0;\r\n\r\n  for (let i = 0; i < offset; ++i) {\r\n    const chr = input.charAt(i);\r\n    if (chr == \"\\n\") {\r\n      col = 0;\r\n      row += 1;\r\n    } else {\r\n      col += 1;\r\n      if (col > maxCols) {\r\n        col = 0;\r\n        row += 1;\r\n      }\r\n    }\r\n  }\r\n\r\n  return { row, col };\r\n}\r\n\r\n/**\r\n * Counts the lines in the given input\r\n */\r\nexport function countLines(input, maxCols) {\r\n  return offsetToColRow(input, input.replace(ansiRegex(), \"\").length, maxCols).row + 1;\r\n}\r\n\r\n/**\r\n * Checks if there is an incomplete input\r\n *\r\n * An incomplete input is considered:\r\n * - An input that contains unterminated single quotes\r\n * - An input that contains unterminated double quotes\r\n * - An input that ends with \"\\\"\r\n * - An input that has an incomplete boolean shell expression (&& and ||)\r\n * - An incomplete pipe expression (|)\r\n */\r\nexport function isIncompleteInput(input) {\r\n  // Empty input is not incomplete\r\n  if (input.trim() == \"\") {\r\n    return false;\r\n  }\r\n\r\n  // Check for dangling single-quote strings\r\n  if ((input.match(/'/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling double-quote strings\r\n  if ((input.match(/\"/g) || []).length % 2 !== 0) {\r\n    return true;\r\n  }\r\n  // Check for dangling boolean or pipe operations\r\n  if (\r\n    input\r\n      .split(/(\\|\\||\\||&&)/g)\r\n      .pop()\r\n      .trim() == \"\"\r\n  ) {\r\n    return true;\r\n  }\r\n  // Check for tailing slash\r\n  if (input.endsWith(\"\\\\\") && !input.endsWith(\"\\\\\\\\\")) {\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\n/**\r\n * Returns true if the expression ends on a tailing whitespace\r\n */\r\nexport function hasTailingWhitespace(input) {\r\n  return input.match(/[^\\\\][ \\t]$/m) != null;\r\n}\r\n\r\n/**\r\n * Returns the last expression in the given input\r\n */\r\nexport function getLastToken(input) {\r\n  // Empty expressions\r\n  if (input.trim() === \"\") return \"\";\r\n  if (hasTailingWhitespace(input)) return \"\";\r\n\r\n  // Last token\r\n  const tokens = parse(input);\r\n  return tokens.pop() || \"\";\r\n}\r\n\r\n/**\r\n * Returns the auto-complete candidates for the given input\r\n */\r\nexport function collectAutocompleteCandidates(callbacks, input) {\r\n  const tokens = parse(input);\r\n  let index = tokens.length - 1;\r\n  let expr = tokens[index] || \"\";\r\n\r\n  // Empty expressions\r\n  if (input.trim() === \"\") {\r\n    index = 0;\r\n    expr = \"\";\r\n  } else if (hasTailingWhitespace(input)) {\r\n    // Expressions with danging space\r\n    index += 1;\r\n    expr = \"\";\r\n  }\r\n\r\n  // Collect all auto-complete candidates from the callbacks\r\n  const all = callbacks.reduce((candidates, { fn, args }) => {\r\n    try {\r\n      return candidates.concat(fn(index, tokens, ...args));\r\n    } catch (e) {\r\n      console.error(\"Auto-complete error:\", e);\r\n      return candidates;\r\n    }\r\n  }, []);\r\n\r\n  // Filter only the ones starting with the expression\r\n  return all.filter(txt => txt.startsWith(expr));\r\n}\r\n\r\n\r\nexport function getSharedFragment(fragment, candidates) {\r\n\r\n  // end loop when fragment length = first candidate length\r\n  if (fragment.length >= candidates[0].length) return fragment;\r\n  \r\n  // save old fragemnt\r\n  const oldFragment = fragment;\r\n  \r\n  // get new fragment\r\n  fragment += candidates[0].slice(fragment.length, fragment.length+1);\r\n\r\n  for (let i=0; i<candidates.length; i++ ) {\r\n\r\n    // return null when there's a wrong candidate\r\n    if (!candidates[i].startsWith(oldFragment)) return null;\r\n\r\n    if (!candidates[i].startsWith(fragment)) {\r\n      return oldFragment;\r\n    }\r\n  }\r\n\r\n  return getSharedFragment(fragment, candidates);\r\n}\r\n","import ansiRegex from \"ansi-regex\";\r\nimport { HistoryController } from \"./HistoryController\";\r\nimport {\r\n  closestLeftBoundary,\r\n  closestRightBoundary,\r\n  collectAutocompleteCandidates,\r\n  countLines,\r\n  getLastToken,\r\n  hasTailingWhitespace,\r\n  isIncompleteInput,\r\n  offsetToColRow,\r\n  getSharedFragment\r\n} from \"./Utils\";\r\n\r\n/**\r\n * A local terminal controller is responsible for displaying messages\r\n * and handling local echo for the terminal.\r\n *\r\n * Local echo supports most of bash-like input primitives. Namely:\r\n * - Arrow navigation on the input\r\n * - Alt-arrow for word-boundary navigation\r\n * - Alt-backspace for word-boundary deletion\r\n * - Multi-line input for incomplete commands\r\n * - Auto-complete hooks\r\n */\r\nexport default class LocalEchoController {\r\n  constructor(term = null, options = {}) {\r\n    this.term = term;\r\n    this._handleTermData = this.handleTermData.bind(this);\r\n    this._handleTermResize = this.handleTermResize.bind(this)\r\n    \r\n    this.history = new HistoryController(options.historySize || 10);\r\n    this.maxAutocompleteEntries = options.maxAutocompleteEntries || 100;\r\n\r\n    this._autocompleteHandlers = [];\r\n    this._active = false;\r\n    this._input = \"\";\r\n    this._cursor = 0;\r\n    this._activePrompt = null;\r\n    this._activeCharPrompt = null;\r\n    this._termSize = {\r\n      cols: 0,\r\n      rows: 0,\r\n    };\r\n\r\n    this._disposables = [];\r\n    \r\n    if (term) {\r\n      if (term.loadAddon) term.loadAddon(this);\r\n      else this.attach();\r\n    }\r\n  }\r\n\r\n  // xterm.js new plugin API:\r\n  activate(term) {\r\n    this.term = term;\r\n    this.attach();\r\n  }\r\n  dispose() {\r\n    this.detach();\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // User-Facing API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  \r\n  /**\r\n   *  Detach the controller from the terminal\r\n   */\r\n  detach() {\r\n    if (this.term.off) {\r\n      this.term.off(\"data\", this._handleTermData);\r\n      this.term.off(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.forEach(d => d.dispose());\r\n      this._disposables = [];\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Attach controller to the terminal, handling events\r\n   */\r\n  attach() {\r\n    if (this.term.on) {\r\n      this.term.on(\"data\", this._handleTermData);\r\n      this.term.on(\"resize\", this._handleTermResize);\r\n    } else {\r\n      this._disposables.push(this.term.onData(this._handleTermData));\r\n      this._disposables.push(this.term.onResize(this._handleTermResize));\r\n    }\r\n    this._termSize = {\r\n      cols: this.term.cols,\r\n      rows: this.term.rows,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Register a handler that will be called to satisfy auto-completion\r\n   */\r\n  addAutocompleteHandler(fn, ...args) {\r\n    this._autocompleteHandlers.push({\r\n      fn,\r\n      args\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Remove a previously registered auto-complete handler\r\n   */\r\n  removeAutocompleteHandler(fn) {\r\n    const idx = this._autocompleteHandlers.findIndex(e => e.fn === fn);\r\n    if (idx === -1) return;\r\n\r\n    this._autocompleteHandlers.splice(idx, 1);\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will resolve when the user has completed\r\n   * typing a single line\r\n   */\r\n  read(prompt, continuationPrompt = \"> \") {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activePrompt = {\r\n        prompt,\r\n        continuationPrompt,\r\n        resolve,\r\n        reject\r\n      };\r\n\r\n      this._input = \"\";\r\n      this._cursor = 0;\r\n      this._active = true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Return a promise that will be resolved when the user types a single\r\n   * character.\r\n   *\r\n   * This can be active in addition to `.read()` and will be resolved in\r\n   * priority before it.\r\n   */\r\n  readChar(prompt) {\r\n    return new Promise((resolve, reject) => {\r\n      this.term.write(prompt);\r\n      this._activeCharPrompt = {\r\n        prompt,\r\n        resolve,\r\n        reject\r\n      };\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Abort a pending read operation\r\n   */\r\n  abortRead(reason = \"aborted\") {\r\n    if (this._activePrompt != null || this._activeCharPrompt != null) {\r\n      this.term.write(\"\\r\\n\");\r\n    }\r\n    if (this._activePrompt != null) {\r\n      this._activePrompt.reject(reason);\r\n      this._activePrompt = null;\r\n    }\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.reject(reason);\r\n      this._activeCharPrompt = null;\r\n    }\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Prints a message and changes line\r\n   */\r\n  println(message) {\r\n    this.print(message + \"\\n\");\r\n  }\r\n\r\n  /**\r\n   * Prints a message and properly handles new-lines\r\n   */\r\n  print(message) {\r\n    const normInput = message.replace(/[\\r\\n]+/g, \"\\n\");\r\n    this.term.write(normInput.replace(/\\n/g, \"\\r\\n\"));\r\n  }\r\n\r\n  /**\r\n   * Prints a list of items using a wide-format\r\n   */\r\n  printWide(items, padding = 2) {\r\n    if (items.length == 0) return println(\"\");\r\n\r\n    // Compute item sizes and matrix row/cols\r\n    const itemWidth =\r\n      items.reduce((width, item) => Math.max(width, item.length), 0) + padding;\r\n    const wideCols = Math.floor(this._termSize.cols / itemWidth);\r\n    const wideRows = Math.ceil(items.length / wideCols);\r\n\r\n    // Print matrix\r\n    let i = 0;\r\n    for (let row = 0; row < wideRows; ++row) {\r\n      let rowStr = \"\";\r\n\r\n      // Prepare columns\r\n      for (let col = 0; col < wideCols; ++col) {\r\n        if (i < items.length) {\r\n          let item = items[i++];\r\n          item += \" \".repeat(itemWidth - item.length);\r\n          rowStr += item;\r\n        }\r\n      }\r\n      this.println(rowStr);\r\n    }\r\n  }\r\n\r\n  /////////////////////////////////////////////////////////////////////////////\r\n  // Internal API\r\n  /////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   * Apply prompts to the given input\r\n   */\r\n  applyPrompts(input) {\r\n    const prompt = (this._activePrompt || {}).prompt || \"\";\r\n    const continuationPrompt =\r\n      (this._activePrompt || {}).continuationPrompt || \"\";\r\n\r\n    return prompt + input.replace(/\\n/g, \"\\n\" + continuationPrompt);\r\n  }\r\n\r\n  /**\r\n   * Advances the `offset` as required in order to accompany the prompt\r\n   * additions to the input.\r\n   */\r\n  applyPromptOffset(input, offset) {\r\n    const newInput = this.applyPrompts(input.substr(0, offset));\r\n    return newInput.replace(ansiRegex(), \"\").length;\r\n  }\r\n\r\n  /**\r\n   * Clears the current prompt\r\n   *\r\n   * This function will erase all the lines that display the current prompt\r\n   * and move the cursor in the beginning of the first line of the prompt.\r\n   */\r\n  clearInput() {\r\n    const currentPrompt = this.applyPrompts(this._input);\r\n\r\n    // Get the overall number of lines to clear\r\n    const allRows = countLines(currentPrompt, this._termSize.cols);\r\n\r\n    // Get the line we are currently in\r\n    const promptCursor = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col, row } = offsetToColRow(\r\n      currentPrompt,\r\n      promptCursor,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // First move on the last line\r\n    const moveRows = allRows - row - 1;\r\n    for (var i = 0; i < moveRows; ++i) this.term.write(\"\\x1B[E\");\r\n\r\n    // Clear current input line(s)\r\n    this.term.write(\"\\r\\x1B[K\");\r\n    for (var i = 1; i < allRows; ++i) this.term.write(\"\\x1B[F\\x1B[K\");\r\n  }\r\n\r\n  /**\r\n   * Replace input with the new input given\r\n   *\r\n   * This function clears all the lines that the current input occupies and\r\n   * then replaces them with the new input.\r\n   */\r\n  setInput(newInput, clearInput = true) {\r\n    // Clear current input\r\n    if (clearInput) this.clearInput();\r\n\r\n    // Write the new input lines, including the current prompt\r\n    const newPrompt = this.applyPrompts(newInput);\r\n    this.print(newPrompt);\r\n\r\n    // Trim cursor overflow\r\n    if (this._cursor > newInput.length) {\r\n      this._cursor = newInput.length;\r\n    }\r\n\r\n    // Move the cursor to the appropriate row/col\r\n    const newCursor = this.applyPromptOffset(newInput, this._cursor);\r\n    const newLines = countLines(newPrompt, this._termSize.cols);\r\n    const { col, row } = offsetToColRow(\r\n      newPrompt,\r\n      newCursor,\r\n      this._termSize.cols\r\n    );\r\n    const moveUpRows = newLines - row - 1;\r\n\r\n    this.term.write(\"\\r\");\r\n    for (var i = 0; i < moveUpRows; ++i) this.term.write(\"\\x1B[F\");\r\n    for (var i = 0; i < col; ++i) this.term.write(\"\\x1B[C\");\r\n\r\n    // Replace input\r\n    this._input = newInput;\r\n  }\r\n\r\n  /**\r\n   * This function completes the current input, calls the given callback\r\n   * and then re-displays the prompt.\r\n   */\r\n  printAndRestartPrompt(callback) {\r\n    const cursor = this._cursor;\r\n\r\n    // Complete input\r\n    this.setCursor(this._input.length);\r\n    this.term.write(\"\\r\\n\");\r\n\r\n    // Prepare a function that will resume prompt\r\n    const resume = () => {\r\n      this._cursor = cursor;\r\n      this.setInput(this._input);\r\n    };\r\n\r\n    // Call the given callback to echo something, and if there is a promise\r\n    // returned, wait for the resolution before resuming prompt.\r\n    const ret = callback();\r\n    if (ret == null) {\r\n      resume();\r\n    } else {\r\n      ret.then(resume);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Set the new cursor position, as an offset on the input string\r\n   *\r\n   * This function:\r\n   * - Calculates the previous and current\r\n   */\r\n  setCursor(newCursor) {\r\n    if (newCursor < 0) newCursor = 0;\r\n    if (newCursor > this._input.length) newCursor = this._input.length;\r\n\r\n    // Apply prompt formatting to get the visual status of the display\r\n    const inputWithPrompt = this.applyPrompts(this._input);\r\n    const inputLines = countLines(inputWithPrompt, this._termSize.cols);\r\n\r\n    // Estimate previous cursor position\r\n    const prevPromptOffset = this.applyPromptOffset(this._input, this._cursor);\r\n    const { col: prevCol, row: prevRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      prevPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Estimate next cursor position\r\n    const newPromptOffset = this.applyPromptOffset(this._input, newCursor);\r\n    const { col: newCol, row: newRow } = offsetToColRow(\r\n      inputWithPrompt,\r\n      newPromptOffset,\r\n      this._termSize.cols\r\n    );\r\n\r\n    // Adjust vertically\r\n    if (newRow > prevRow) {\r\n      for (let i = prevRow; i < newRow; ++i) this.term.write(\"\\x1B[B\");\r\n    } else {\r\n      for (let i = newRow; i < prevRow; ++i) this.term.write(\"\\x1B[A\");\r\n    }\r\n\r\n    // Adjust horizontally\r\n    if (newCol > prevCol) {\r\n      for (let i = prevCol; i < newCol; ++i) this.term.write(\"\\x1B[C\");\r\n    } else {\r\n      for (let i = newCol; i < prevCol; ++i) this.term.write(\"\\x1B[D\");\r\n    }\r\n\r\n    // Set new offset\r\n    this._cursor = newCursor;\r\n  }\r\n\r\n  /**\r\n   * Move cursor at given direction\r\n   */\r\n  handleCursorMove(dir) {\r\n    if (dir > 0) {\r\n      const num = Math.min(dir, this._input.length - this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    } else if (dir < 0) {\r\n      const num = Math.max(dir, -this._cursor);\r\n      this.setCursor(this._cursor + num);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Erase a character at cursor location\r\n   */\r\n  handleCursorErase(backspace) {\r\n    const { _cursor, _input } = this;\r\n    if (backspace) {\r\n      if (_cursor <= 0) return;\r\n      const newInput = _input.substr(0, _cursor - 1) + _input.substr(_cursor);\r\n      this.clearInput();\r\n      this._cursor -= 1;\r\n      this.setInput(newInput, false);\r\n    } else {\r\n      const newInput = _input.substr(0, _cursor) + _input.substr(_cursor + 1);\r\n      this.setInput(newInput);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Insert character at cursor location\r\n   */\r\n  handleCursorInsert(data) {\r\n    const { _cursor, _input } = this;\r\n    const newInput = _input.substr(0, _cursor) + data + _input.substr(_cursor);\r\n    this._cursor += data.length;\r\n    this.setInput(newInput);\r\n  }\r\n\r\n  /**\r\n   * Handle input completion\r\n   */\r\n  handleReadComplete() {\r\n    if (this.history) {\r\n      this.history.push(this._input);\r\n    }\r\n    if (this._activePrompt) {\r\n      this._activePrompt.resolve(this._input);\r\n      this._activePrompt = null;\r\n    }\r\n    this.term.write(\"\\r\\n\");\r\n    this._active = false;\r\n  }\r\n\r\n  /**\r\n   * Handle terminal resize\r\n   *\r\n   * This function clears the prompt using the previous configuration,\r\n   * updates the cached terminal size information and then re-renders the\r\n   * input. This leads (most of the times) into a better formatted input.\r\n   */\r\n  handleTermResize(data) {\r\n    const { rows, cols } = data;\r\n    this.clearInput();\r\n    this._termSize = { cols, rows };\r\n    this.setInput(this._input, false);\r\n  }\r\n\r\n  /**\r\n   * Handle terminal input\r\n   */\r\n  handleTermData(data) {\r\n    if (!this._active) return;\r\n\r\n    // If we have an active character prompt, satisfy it in priority\r\n    if (this._activeCharPrompt != null) {\r\n      this._activeCharPrompt.resolve(data);\r\n      this._activeCharPrompt = null;\r\n      this.term.write(\"\\r\\n\");\r\n      return;\r\n    }\r\n\r\n    // If this looks like a pasted input, expand it\r\n    if (data.length > 3 && data.charCodeAt(0) !== 0x1b) {\r\n      const normData = data.replace(/[\\r\\n]+/g, \"\\r\");\r\n      Array.from(normData).forEach(c => this.handleData(c));\r\n    } else {\r\n      this.handleData(data);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Handle a single piece of information from the terminal.\r\n   */\r\n  handleData(data) {\r\n    if (!this._active) return;\r\n    const ord = data.charCodeAt(0);\r\n    let ofs;\r\n\r\n    // Handle ANSI escape sequences\r\n    if (ord == 0x1b) {\r\n      switch (data.substr(1)) {\r\n        case \"[A\": // Up arrow\r\n          if (this.history) {\r\n            let value = this.history.getPrevious();\r\n            if (value) {\r\n              this.setInput(value);\r\n              this.setCursor(value.length);\r\n            }\r\n          }\r\n          break;\r\n\r\n        case \"[B\": // Down arrow\r\n          if (this.history) {\r\n            let value = this.history.getNext();\r\n            if (!value) value = \"\";\r\n            this.setInput(value);\r\n            this.setCursor(value.length);\r\n          }\r\n          break;\r\n\r\n        case \"[D\": // Left Arrow\r\n          this.handleCursorMove(-1);\r\n          break;\r\n\r\n        case \"[C\": // Right Arrow\r\n          this.handleCursorMove(1);\r\n          break;\r\n\r\n        case \"[3~\": // Delete\r\n          this.handleCursorErase(false);\r\n          break;\r\n\r\n        case \"[F\": // End\r\n          this.setCursor(this._input.length);\r\n          break;\r\n\r\n        case \"[H\": // Home\r\n          this.setCursor(0);\r\n          break;\r\n\r\n        case \"b\": // ALT + LEFT\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"f\": // ALT + RIGHT\r\n          ofs = closestRightBoundary(this._input, this._cursor);\r\n          if (ofs != null) this.setCursor(ofs);\r\n          break;\r\n\r\n        case \"\\x7F\": // CTRL + BACKSPACE\r\n          ofs = closestLeftBoundary(this._input, this._cursor);\r\n          if (ofs != null) {\r\n            this.setInput(\r\n              this._input.substr(0, ofs) + this._input.substr(this._cursor)\r\n            );\r\n            this.setCursor(ofs);\r\n          }\r\n          break;\r\n      }\r\n\r\n      // Handle special characters\r\n    } else if (ord < 32 || ord === 0x7f) {\r\n      switch (data) {\r\n        case \"\\r\": // ENTER\r\n          if (isIncompleteInput(this._input)) {\r\n            this.handleCursorInsert(\"\\n\");\r\n          } else {\r\n            this.handleReadComplete();\r\n          }\r\n          break;\r\n\r\n        case \"\\x7F\": // BACKSPACE\r\n          this.handleCursorErase(true);\r\n          break;\r\n\r\n        case \"\\t\": // TAB\r\n          if (this._autocompleteHandlers.length > 0) {\r\n            const inputFragment = this._input.substr(0, this._cursor);\r\n            const hasTailingSpace = hasTailingWhitespace(inputFragment);\r\n            const candidates = collectAutocompleteCandidates(\r\n              this._autocompleteHandlers,\r\n              inputFragment\r\n            );\r\n\r\n            // Sort candidates\r\n            candidates.sort();\r\n\r\n            // Depending on the number of candidates, we are handing them in\r\n            // a different way.\r\n            if (candidates.length === 0) {\r\n              // No candidates? Just add a space if there is none already\r\n              if (!hasTailingSpace) {\r\n                this.handleCursorInsert(\" \");\r\n              }\r\n            } else if (candidates.length === 1) {\r\n              // Just a single candidate? Complete\r\n              const lastToken = getLastToken(inputFragment);\r\n              this.handleCursorInsert(\r\n                candidates[0].substr(lastToken.length) + \" \"\r\n              );\r\n            } else if (candidates.length <= this.maxAutocompleteEntries) {\r\n\r\n              // search for a shared fragement\r\n              const sameFragment = getSharedFragment(inputFragment, candidates);\r\n              \r\n              // if there's a shared fragement between the candidates\r\n              // print complete the shared fragment\r\n              if (sameFragment) {\r\n                const lastToken = getLastToken(inputFragment);\r\n                this.handleCursorInsert(\r\n                  sameFragment.substr(lastToken.length)\r\n                );\r\n              }\r\n\r\n              // If we are less than maximum auto-complete candidates, print\r\n              // them to the user and re-start prompt\r\n              this.printAndRestartPrompt(() => {\r\n                this.printWide(candidates);\r\n              });\r\n            } else {\r\n              // If we have more than maximum auto-complete candidates, print\r\n              // them only if the user acknowledges a warning\r\n              this.printAndRestartPrompt(() =>\r\n                this.readChar(\r\n                  `Display all ${candidates.length} possibilities? (y or n)`\r\n                ).then(yn => {\r\n                  if (yn == \"y\" || yn == \"Y\") {\r\n                    this.printWide(candidates);\r\n                  }\r\n                })\r\n              );\r\n            }\r\n          } else {\r\n            this.handleCursorInsert(\"    \");\r\n          }\r\n          break;\r\n\r\n        case \"\\x03\": // CTRL+C\r\n          this.setCursor(this._input.length);\r\n          this.term.write(\"^C\\r\\n\" + ((this._activePrompt || {}).prompt || \"\"));\r\n          this._input = \"\";\r\n          this._cursor = 0;\r\n          if (this.history) this.history.rewind();\r\n          break;\r\n      }\r\n\r\n      // Handle visible characters\r\n    } else {\r\n      this.handleCursorInsert(data);\r\n    }\r\n  }\r\n}\r\n","import LocalEchoController from \"./lib/LocalEchoController\";\r\nexport { HistoryController } from './lib/HistoryController';\r\n\r\nexport default LocalEchoController;\r\n"],"sourceRoot":""}